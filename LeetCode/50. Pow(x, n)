/*
初始代码，但是在碰到测试实例为 1.00000  2147483647 时超时
*/
double myPow(double x, int n){
    if(n<0)
    {
        x = 1/x;
        n = -n;
    }
    double s = 1;//s 不要等于 x 或 0
    while(n--)//包括了 n = 0 的情况.
    {
        s *= x;
    }
    return s;
}

//二代版本，低端二分，仍然在实例为 1.00000 -2147483648 时超时
double myPow(double x, long int n){//把 int 改为 long int 也没用
    if(n<0)
    {
        x = 1/x;
        n = -n;//这样取反时，碰到 -2147483648 时出错，int正数最大值为 2147483647
    }
    double s = 1;
    int i = n/2;
    while(i--)//包括了 n = 0 的情况.
    {
        s *= x;
    }
    if(n%2==0)
    return s*s;
    return s*s*x;
}

/*
快速幂法 把 n 看作二进制，假设求a^b,按照朴素算法就是把a连乘b次，这样一来时间复杂度是O(n)级，快速幂能做到O(logn)
首先把b写成它的二进制形式，设该二进制数第i位的权值为2^(i-1)，i * 2^(i-1)是每一次要做的乘方次数
那么假设b=11，11的二进制是1011，11 = 2³×1 + 2²×0 + 2¹×1 + 2º×1=2³+2¹+2º，所以：a¹¹=  a^2º* a ^2¹ * a^2³
代码中n&1是取n的二进制末位，只有当前位为1时才要乘； n/=2是将n右移一位，取新的位做末位（与二进制原理有关）；x*=x就是X^(2^i)，是下一次要乘的因子
*/
double myPow(double x, int n)
{
    double s = 1;
    int a = n;//便于判断 n 是否小于0，因为后面将 n 看作二进制，到最后 n 为0，也无法用 s 来判断。
    while(n)
    {
        if(n&1)
            s *= x;
        x*=x;
        n/=2;//n = n>>1 超出时间限制
    }
    return a>=0?s:1/s;
}
