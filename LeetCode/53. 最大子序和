//暴力解法
int maxSubArray(int* nums, int numsSize){
    int i,j,k,l = nums[0];
    for(i = 0; i<numsSize; i++)
    {
        k = 0;
        for(j = i; j<numsSize; j++)
        {
            k += nums[j];
            l = l>k?l:k;
        }
    }
    return l;
}

//动态规划
/*
假设 nums 数组的长度是 n，下标从 0 到 n−1。
我们用 ai 代表 nums[i]，用 f(i) 代表以第 i个数结尾的「连续子数组的最大和」，那么很显然我们要求的答案就是：
max⁡(0≤i≤n−1){f(i)}
因此我们只需要求出每个位置的 f(i)，然后返回 f 数组中的最大值即可。那么我们如何求 f(i) 呢？我们可以考虑 ai 单独成为一段还是加入 f(i−1) 对应的那一段，
这取决于 ai 和 f(i−1)+ai 的大小，我们希望获得一个比较大的，于是可以写出这样的动态规划转移方程：
f(i)=max⁡{f(i−1)+ai,ai}
*/
int maxSubArray(int* nums, int numsSize){
    int i,sum = 0,k = nums[0];
    for(i = 0; i<numsSize; i++)
    {
        sum = sum+nums[i]>nums[i]?sum+nums[i]:nums[i];
        k = sum>k?sum:k;
    }
    return k;
}

//分治
